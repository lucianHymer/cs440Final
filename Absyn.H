#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class Function;
class Decl;
class FDecl;
class Stm;
class Exp;
class Type;
class Prog;
class Global;
class Fun;
class Dec;
class FDec;
class SDecl;
class SExp;
class SBlock;
class SWhile;
class SRepeat;
class SIf;
class SIfThenElse;
class SIfThen;
class SFor;
class SForScoped;
class SReturn;
class EAss;
class ELt;
class EGt;
class EAdd;
class ESub;
class EMul;
class Call;
class EVar;
class EStr;
class EInt;
class EDouble;
class TInt;
class TDouble;
class ListFunction;
class ListStm;
class ListFDecl;
class ListIdent;
class ListExp;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitFunction(Function *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitFDecl(FDecl *p) = 0;
  virtual void visitStm(Stm *p) = 0;
  virtual void visitExp(Exp *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitProg(Prog *p) = 0;
  virtual void visitGlobal(Global *p) = 0;
  virtual void visitFun(Fun *p) = 0;
  virtual void visitDec(Dec *p) = 0;
  virtual void visitFDec(FDec *p) = 0;
  virtual void visitSDecl(SDecl *p) = 0;
  virtual void visitSExp(SExp *p) = 0;
  virtual void visitSBlock(SBlock *p) = 0;
  virtual void visitSWhile(SWhile *p) = 0;
  virtual void visitSRepeat(SRepeat *p) = 0;
  virtual void visitSIf(SIf *p) = 0;
  virtual void visitSIfThenElse(SIfThenElse *p) = 0;
  virtual void visitSIfThen(SIfThen *p) = 0;
  virtual void visitSFor(SFor *p) = 0;
  virtual void visitSForScoped(SForScoped *p) = 0;
  virtual void visitSReturn(SReturn *p) = 0;
  virtual void visitEAss(EAss *p) = 0;
  virtual void visitELt(ELt *p) = 0;
  virtual void visitEGt(EGt *p) = 0;
  virtual void visitEAdd(EAdd *p) = 0;
  virtual void visitESub(ESub *p) = 0;
  virtual void visitEMul(EMul *p) = 0;
  virtual void visitCall(Call *p) = 0;
  virtual void visitEVar(EVar *p) = 0;
  virtual void visitEStr(EStr *p) = 0;
  virtual void visitEInt(EInt *p) = 0;
  virtual void visitEDouble(EDouble *p) = 0;
  virtual void visitTInt(TInt *p) = 0;
  virtual void visitTDouble(TDouble *p) = 0;
  virtual void visitListFunction(ListFunction *p) = 0;
  virtual void visitListStm(ListStm *p) = 0;
  virtual void visitListFDecl(ListFDecl *p) = 0;
  virtual void visitListIdent(ListIdent *p) = 0;
  virtual void visitListExp(ListExp *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;

};

class Function : public Visitable
{
public:
  virtual Function *clone() const = 0;

};

class Decl : public Visitable
{
public:
  virtual Decl *clone() const = 0;

};

class FDecl : public Visitable
{
public:
  virtual FDecl *clone() const = 0;

};

class Stm : public Visitable
{
public:
  virtual Stm *clone() const = 0;

};

class Exp : public Visitable
{
public:
  virtual Exp *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};



class Prog : public Program
{
public:
  ListFunction *listfunction_;

  Prog(const Prog &);
  Prog &operator=(const Prog &);
  Prog(ListFunction *p1);
  ~Prog();
  virtual void accept(Visitor *v);
  virtual Prog *clone() const;
  void swap(Prog &);
};

class Global : public Function
{
public:
  Type *type_;
  Ident ident_;

  Global(const Global &);
  Global &operator=(const Global &);
  Global(Type *p1, Ident p2);
  ~Global();
  virtual void accept(Visitor *v);
  virtual Global *clone() const;
  void swap(Global &);
};

class Fun : public Function
{
public:
  Type *type_;
  Ident ident_;
  ListFDecl *listfdecl_;
  ListStm *liststm_;

  Fun(const Fun &);
  Fun &operator=(const Fun &);
  Fun(Type *p1, Ident p2, ListFDecl *p3, ListStm *p4);
  ~Fun();
  virtual void accept(Visitor *v);
  virtual Fun *clone() const;
  void swap(Fun &);
};

class Dec : public Decl
{
public:
  Type *type_;
  ListIdent *listident_;

  Dec(const Dec &);
  Dec &operator=(const Dec &);
  Dec(Type *p1, ListIdent *p2);
  ~Dec();
  virtual void accept(Visitor *v);
  virtual Dec *clone() const;
  void swap(Dec &);
};

class FDec : public FDecl
{
public:
  Type *type_;
  Ident ident_;

  FDec(const FDec &);
  FDec &operator=(const FDec &);
  FDec(Type *p1, Ident p2);
  ~FDec();
  virtual void accept(Visitor *v);
  virtual FDec *clone() const;
  void swap(FDec &);
};

class SDecl : public Stm
{
public:
  Decl *decl_;

  SDecl(const SDecl &);
  SDecl &operator=(const SDecl &);
  SDecl(Decl *p1);
  ~SDecl();
  virtual void accept(Visitor *v);
  virtual SDecl *clone() const;
  void swap(SDecl &);
};

class SExp : public Stm
{
public:
  Exp *exp_;

  SExp(const SExp &);
  SExp &operator=(const SExp &);
  SExp(Exp *p1);
  ~SExp();
  virtual void accept(Visitor *v);
  virtual SExp *clone() const;
  void swap(SExp &);
};

class SBlock : public Stm
{
public:
  ListStm *liststm_;

  SBlock(const SBlock &);
  SBlock &operator=(const SBlock &);
  SBlock(ListStm *p1);
  ~SBlock();
  virtual void accept(Visitor *v);
  virtual SBlock *clone() const;
  void swap(SBlock &);
};

class SWhile : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  SWhile(const SWhile &);
  SWhile &operator=(const SWhile &);
  SWhile(Exp *p1, Stm *p2);
  ~SWhile();
  virtual void accept(Visitor *v);
  virtual SWhile *clone() const;
  void swap(SWhile &);
};

class SRepeat : public Stm
{
public:
  Stm *stm_;
  Exp *exp_;

  SRepeat(const SRepeat &);
  SRepeat &operator=(const SRepeat &);
  SRepeat(Stm *p1, Exp *p2);
  ~SRepeat();
  virtual void accept(Visitor *v);
  virtual SRepeat *clone() const;
  void swap(SRepeat &);
};

class SIf : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  SIf(const SIf &);
  SIf &operator=(const SIf &);
  SIf(Exp *p1, Stm *p2);
  ~SIf();
  virtual void accept(Visitor *v);
  virtual SIf *clone() const;
  void swap(SIf &);
};

class SIfThenElse : public Stm
{
public:
  Exp *exp_;
  Stm *stm_1;
  Stm *stm_2;

  SIfThenElse(const SIfThenElse &);
  SIfThenElse &operator=(const SIfThenElse &);
  SIfThenElse(Exp *p1, Stm *p2, Stm *p3);
  ~SIfThenElse();
  virtual void accept(Visitor *v);
  virtual SIfThenElse *clone() const;
  void swap(SIfThenElse &);
};

class SIfThen : public Stm
{
public:
  Exp *exp_;
  Stm *stm_;

  SIfThen(const SIfThen &);
  SIfThen &operator=(const SIfThen &);
  SIfThen(Exp *p1, Stm *p2);
  ~SIfThen();
  virtual void accept(Visitor *v);
  virtual SIfThen *clone() const;
  void swap(SIfThen &);
};

class SFor : public Stm
{
public:
  Exp *exp_1;
  Exp *exp_2;
  Exp *exp_3;
  Stm *stm_;

  SFor(const SFor &);
  SFor &operator=(const SFor &);
  SFor(Exp *p1, Exp *p2, Exp *p3, Stm *p4);
  ~SFor();
  virtual void accept(Visitor *v);
  virtual SFor *clone() const;
  void swap(SFor &);
};

class SForScoped : public Stm
{
public:
  Type *type_;
  Ident ident_;
  Exp *exp_1;
  Exp *exp_2;
  Exp *exp_3;
  Stm *stm_;

  SForScoped(const SForScoped &);
  SForScoped &operator=(const SForScoped &);
  SForScoped(Type *p1, Ident p2, Exp *p3, Exp *p4, Exp *p5, Stm *p6);
  ~SForScoped();
  virtual void accept(Visitor *v);
  virtual SForScoped *clone() const;
  void swap(SForScoped &);
};

class SReturn : public Stm
{
public:
  Exp *exp_;

  SReturn(const SReturn &);
  SReturn &operator=(const SReturn &);
  SReturn(Exp *p1);
  ~SReturn();
  virtual void accept(Visitor *v);
  virtual SReturn *clone() const;
  void swap(SReturn &);
};

class EAss : public Exp
{
public:
  Ident ident_;
  Exp *exp_;

  EAss(const EAss &);
  EAss &operator=(const EAss &);
  EAss(Ident p1, Exp *p2);
  ~EAss();
  virtual void accept(Visitor *v);
  virtual EAss *clone() const;
  void swap(EAss &);
};

class ELt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ELt(const ELt &);
  ELt &operator=(const ELt &);
  ELt(Exp *p1, Exp *p2);
  ~ELt();
  virtual void accept(Visitor *v);
  virtual ELt *clone() const;
  void swap(ELt &);
};

class EGt : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EGt(const EGt &);
  EGt &operator=(const EGt &);
  EGt(Exp *p1, Exp *p2);
  ~EGt();
  virtual void accept(Visitor *v);
  virtual EGt *clone() const;
  void swap(EGt &);
};

class EAdd : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EAdd(const EAdd &);
  EAdd &operator=(const EAdd &);
  EAdd(Exp *p1, Exp *p2);
  ~EAdd();
  virtual void accept(Visitor *v);
  virtual EAdd *clone() const;
  void swap(EAdd &);
};

class ESub : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  ESub(const ESub &);
  ESub &operator=(const ESub &);
  ESub(Exp *p1, Exp *p2);
  ~ESub();
  virtual void accept(Visitor *v);
  virtual ESub *clone() const;
  void swap(ESub &);
};

class EMul : public Exp
{
public:
  Exp *exp_1;
  Exp *exp_2;

  EMul(const EMul &);
  EMul &operator=(const EMul &);
  EMul(Exp *p1, Exp *p2);
  ~EMul();
  virtual void accept(Visitor *v);
  virtual EMul *clone() const;
  void swap(EMul &);
};

class Call : public Exp
{
public:
  Ident ident_;
  ListExp *listexp_;

  Call(const Call &);
  Call &operator=(const Call &);
  Call(Ident p1, ListExp *p2);
  ~Call();
  virtual void accept(Visitor *v);
  virtual Call *clone() const;
  void swap(Call &);
};

class EVar : public Exp
{
public:
  Ident ident_;

  EVar(const EVar &);
  EVar &operator=(const EVar &);
  EVar(Ident p1);
  ~EVar();
  virtual void accept(Visitor *v);
  virtual EVar *clone() const;
  void swap(EVar &);
};

class EStr : public Exp
{
public:
  String string_;

  EStr(const EStr &);
  EStr &operator=(const EStr &);
  EStr(String p1);
  ~EStr();
  virtual void accept(Visitor *v);
  virtual EStr *clone() const;
  void swap(EStr &);
};

class EInt : public Exp
{
public:
  Integer integer_;

  EInt(const EInt &);
  EInt &operator=(const EInt &);
  EInt(Integer p1);
  ~EInt();
  virtual void accept(Visitor *v);
  virtual EInt *clone() const;
  void swap(EInt &);
};

class EDouble : public Exp
{
public:
  Double double_;

  EDouble(const EDouble &);
  EDouble &operator=(const EDouble &);
  EDouble(Double p1);
  ~EDouble();
  virtual void accept(Visitor *v);
  virtual EDouble *clone() const;
  void swap(EDouble &);
};

class TInt : public Type
{
public:

  TInt(const TInt &);
  TInt &operator=(const TInt &);
  TInt();
  ~TInt();
  virtual void accept(Visitor *v);
  virtual TInt *clone() const;
  void swap(TInt &);
};

class TDouble : public Type
{
public:

  TDouble(const TDouble &);
  TDouble &operator=(const TDouble &);
  TDouble();
  ~TDouble();
  virtual void accept(Visitor *v);
  virtual TDouble *clone() const;
  void swap(TDouble &);
};



class ListFunction : public Visitable, public std::vector<Function*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFunction *clone() const;
};

class ListStm : public Visitable, public std::vector<Stm*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListStm *clone() const;
};

class ListFDecl : public Visitable, public std::vector<FDecl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListFDecl *clone() const;
};

class ListIdent : public Visitable, public std::vector<Ident>
{
public:
  virtual void accept(Visitor *v);
  virtual ListIdent *clone() const;
};

class ListExp : public Visitable, public std::vector<Exp*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExp *clone() const;
};



#endif
